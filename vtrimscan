#!/bin/bash
#
# Licensing:
#
# Copyright Â© Laurence Lumi 2017
# Licensed GNU General Public License v3
# which can be found here https://www.gnu.org/licenses/gpl-3.0.en.html
#

PROGNAME=`basename $0`
message1()
	{
	echo >&2 ""
	echo >&2 "$PROGNAME:" "$@"
        cat << MESSAGE1
<<<<<<< HEAD
USAGE: $PROGNAME [-f fuzz ] [-m mirror ] [ -r rotate ]
[ -a all boxes ] [-e extend] [-S show mask] [ -n number ] infile [outfile_prefix]
USAGE: $PROGNAME [-h or -help]
=======
USAGE: $PROGNAME gap | holder [-d] [-dd] [-m] [-flip] [-r rotate] [-p pixel] [-e extend] [-fb fbfuzz] [-f fuzz] [-n number] infile [outfile_prefix]
USAGE: $PROGNAME [-h ] [ -help ]
>>>>>>> dev

holder    removeholder   the script for trim the film holder
gap       remove gap     the script will remove the film frame gaps

OPTIONS:

<<<<<<< HEAD
=======

-d          debug          provided usefull debuging and leaves intermediate files behind
-dd         debug          more extensive debugging uses full height intermediate files, which may give a different result from no-debug
-m          mirror         mirrors left to right the scan before it is processed, usefull if the negative was scanned emulsion down
-flip       flip           mirrors the scan vertically before it is processed, usefull if the negative was scanned emulsion down
-r          rotate         rotates the scan before it is processed, positive integer <= 360
-p          pixelwidth     the smallest amount of horizontal pixel that could make a usefull image defaults: 250 
-e          extend         extend crop on each side in pixels; integer; default=0  
>>>>>>> dev
-fb         filmbase       fuzz value used as threshold for removing any white areas from the scan
                           if brighest area of the film base is 75% then the threshold should be less than 25%
                           expressed as (integer) percent 0 to 100; default=25
-f          fuzz           fuzz value used for a threshold to find area outside the frame, either the black film holder or the gaps between frames  
<<<<<<< HEAD
                           expressed as (integer) percent 0 to 100; default=2 for gap and 10 for holder
-m          mirror         mirrors left to right the scan before it is processed, usefull if the negative was scanned emulsion down
-flip       flip          mirrors the scan vertically before it is processed, usefull if the negative was scanned emulsion down
-r          rotate         rotates the scan before it is processed, positive integer <= 360
-d          debug          provided usefull debuging and leaves intermediate files behind
-n          frame number   the starting frame number to use in file name; defaults to #1
-p          pixelwidth     the smallest amount of horizontal pixel that could make a usefull image defaults: 100
-e          extend         extend crop on each side in pixels; integer; default=0  
=======
                           expressed as (integer) percent 0 to 100; default=3 for gap and 10 for holder
-n          frame number   the starting frame number to use in file name; defaults to #1
>>>>>>> dev
MESSAGE1
exit 1
	}
message2()
{
    echo >&2 ""
    echo >&2 "$PROGNAME:" "$@"
    cat  >&2 << MESSAGE2

NAME: $PROGNAME

PURPOSE: to trim the film holder and separate frames of a trimmed film strip


Arguments:

TODO

MESSAGE2
exit 1
}
function DEBUG()
{
 [ ! "$debug" -eq 0 ] &&  $@
}
<<<<<<< HEAD
=======
# quicksorts positional arguments
# return is in array qsort_ret
# Note: iterative, NOT recursive! :)
# First argument is a function name that takes two arguments and compares them
qsort() {
   (($#<=1)) && return 0
   local compare_fun=$1
   shift
   local stack=( 0 $(($#-1)) ) beg end i pivot smaller larger
   qsort_ret=("$@")
   while ((${#stack[@]})); do
      beg=${stack[0]}
      end=${stack[1]}
      stack=( "${stack[@]:2}" )
      smaller=() larger=()
      pivot=${qsort_ret[beg]}
      for ((i=beg+1;i<=end;++i)); do
         if "$compare_fun" "${qsort_ret[i]}" "$pivot"; then
            smaller+=( "${qsort_ret[i]}" )
         else
            larger+=( "${qsort_ret[i]}" )
         fi
      done
      qsort_ret=( "${qsort_ret[@]:0:beg}" "${smaller[@]}" "$pivot" "${larger[@]}" "${qsort_ret[@]:end+1}" )
      if ((${#smaller[@]}>=2)); then stack+=( "$beg" "$((beg+${#smaller[@]}-1))" ); fi
      if ((${#larger[@]}>=2)); then stack+=( "$((end-${#larger[@]}+1))" "$end" ); fi
   done
}
>>>>>>> dev

tmpdir="./"
debug=0
tmpprefix=$tmpdir"_vt_"
filmbase=25
framenumber=1
<<<<<<< HEAD
pixel=100
=======
pixel=250
>>>>>>> dev
extend=0

if [ "$1" = "holder" ]; then
    mode="holder"
    fuzz=7
    shift
elif [ "$1" = "gap" ]; then
    mode="gap"
<<<<<<< HEAD
    fuzz=2
=======
    fuzz=3
>>>>>>> dev
    shift
else
    echo "must specify either holder or gap"
    message2
fi

while [ $# -gt 0 ]
do
    # get parameters
    case "$1" in
        -h|-help)    # help information
            echo ""
            message2
            ;;
        -d)	debug=1
            ;;
        -dd)	debug=2
            ;;
        -m)	MIRROR="-flop"
            ;;
        -flip)	FLIP="-flip"
            ;;
        -r)    # rotate
            shift
            rotate="$1"
            if [[ ! "$rotate" =~ ^[0-9]+$ ]] || [ "$rotate" -lt 0 -o "$rotate" -gt 360 ]; then
                echo "--- rotate=$rotate must be a positive integer value between 0 and 360 ---"
                message1
            fi
            ROTATE="-rotate $rotate +repage"
            ;;
        -p)    # pixel
            shift
            pixel="$1"
            if [[ ! "$pixel" =~ ^[0-9]+$ ]]; then
                echo "--- pixel=$pixel must be a positive integer value ---"
                message1
            fi
            ;;
        -e)    # extend
            shift
            extend="$1"
            if [[ ! "$extend" =~ ^[0-9]+$ ]]; then
                echo "--- extend=$extend must be a positive integer value ---"
                message1
            fi
            ;;
        -fb)    # filmbase 
            shift
            filmbase="$1"
            if [[ ! "$filmbase" =~ ^[0-9]+$ ]] || [ "$filmbase" -lt 0 -o "$filmbase" -gt 100 ]; then
                echo "--- filmbase=$filmbase must be a positive integer value between 0 and 100 ---"
                message1
            fi
            ;;
        -f)    # fuzz
            shift
            fuzz="$1"
            if [[ ! "$fuzz" =~ ^[0-9]+$ ]] || [ "$fuzz" -lt 0 -o "$fuzz" -gt 100 ]; then
                echo "--- fuzz=$fuzz must be a positive integer value between 0 and 100 ---"
                message1
            fi
            ;;
        -n)    # number
            shift
            framenumber="$1"
            if [[ ! "$framenumber" =~ ^[0-9]+$ ]]; then
                echo "--- framenumber=$framenumber must be a integer value  ---"
                message1
            fi
            ;;
        -)    # STDIN and end of arguments
            break
            ;;
        -*)    # any other - argument
            echo "--- UNKNOWN OPTION ---"
            message1
            ;;
        *)     # end of arguments
            break
            ;;
    esac
    shift   # next option
done

infile=$1
outprefix=$2

if [ -z $infile ]
then
    echo "must provide a filename"
    message2
fi
if [ ! -f "$infile" -o ! -r "$infile" ]; then
    echo "Cannot open: $infile"
    exit 1
fi

if [ -z $outprefix ]; then
    outprefix=${infile%".tif"}_
else
    outprefix=${outprefix%".tif"}_
fi
tmpoutprefix="$tmpprefix"`basename "$outprefix"`
DEBUG echo tmpoutprefix: $tmpoutprefix
DEBUG echo outprefix: $outprefix

#first orientate the image if necessary
if [ ! -z "$MIRROR" ] || [ ! -z "$FLIP" ] || [ ! -z "$ROTATE" ]; then
    echo "re orientating scan before processing"
    reorientatedfile="$tmpoutprefix"reoreintated.tif
    convert $infile $MIRROR $ROTATE $FLIP "$reorientatedfile"
    infile="$reorientatedfile"
fi

DEBUG set -x;

if [ $mode = "gap" ]; then 
    #remove any sprocket holes or missing bits of film use a default of 25% this mean the film base must be darker than 25%
    #this is necessary as the average of the white and dark may match the film base this not necessary when looking for the holder
    #may need to revist this
<<<<<<< HEAD
    tmpfile0="$tmpoutprefix"0.png
=======
    tmpfile0="$tmpoutprefix"0work.tif
>>>>>>> dev
    convert $infile -fuzz "$filmbase"% -fill black -opaque white "$tmpfile0"
else
    #skip the fill step and just use input file directly
    tmpfile0="$infile"
fi

if [ "$debug" -eq 2 ]; then
    #do the conversion in both X an Y easier to visualise but unecessary as all pixel are identical in a vertical line
    #caution this may have side effects as the logic is different compared to the low debug levels
    XY=`convert $infile -format "%wx%h" info:`
<<<<<<< HEAD
    convert "$tmpfile0" -scale x1! -scale $XY! "$tmpoutprefix"1.png
else
    convert "$tmpfile0" -scale x1! "$tmpoutprefix"1.png
fi

if [ $mode = "gap" ]; then 
    stripcolor=(`convert "$tmpoutprefix"1.png -strip -blur 7x7 -format \
=======
    convert "$tmpfile0" -scale x1! -scale $XY! "$tmpoutprefix"1work.tif
else
    convert "$tmpfile0" -scale x1! "$tmpoutprefix"1work.tif
fi

if [ $mode = "gap" ]; then 
    stripcolor=(`convert "$tmpoutprefix"1work.tif -strip -blur 7x7 -format \
>>>>>>> dev
        "%[fx: maxima.r * 100 ] %[fx: maxima.g * 100 ] %[fx: maxima.b * 100 ] " info:`)
    #num=${#stripcolor[*]}
    #echo num:$num
    #for ((i=0;i<num;i++)); do
    #    echo SC:${stripcolor[$i]}
    #done
    opaque="rgb("${stripcolor[0]}"%,"${stripcolor[1]}"%,"${stripcolor[2]}"%)"
else
    opaque="black"
fi


#note sometimes convert reduces the png to 8bit if it can do so when it leaves it at 16bit this is probably because the fill has worked in funny way i.e. not all black and white
<<<<<<< HEAD
convert "$tmpoutprefix"1.png -fuzz "$fuzz"% -fill black -opaque "$opaque" -fill white +opaque black "$tmpoutprefix"2.png
#morphology could be adjusted to remove ghost frames i.e the gap must be x pixels wide
#convert "$tmpoutprefix"2.png -morphology open "5x1:0,1,1,1,0" "$tmpoutprefix"3.png
convert "$tmpoutprefix"2.png -morphology open "Rectangle:"$pixel"x1" "$tmpoutprefix"3.png
=======
convert "$tmpoutprefix"1work.tif -fuzz "$fuzz"% -fill black -opaque "$opaque" -fill white +opaque black "$tmpoutprefix"2work.tif
#morphology could be adjusted to remove ghost frames i.e the gap must be x pixels wide
#convert "$tmpoutprefix"2work.tif -morphology open "5x1:0,1,1,1,0" "$tmpoutprefix"3work.tif
convert "$tmpoutprefix"2work.tif -morphology open "Rectangle:"$pixel"x1" "$tmpoutprefix"3work.tif
>>>>>>> dev
set +x

arr=()
OLD_IFS=$IFS
IFS=$'\n'
<<<<<<< HEAD
arr=(`convert "$tmpoutprefix"3.png -type bilevel \
=======
arr=(`convert "$tmpoutprefix"3work.tif -type bilevel \
>>>>>>> dev
-define connected-components:verbose=true \
-define connected-components:mean-color=true \
-connected-components 4 \
null: | sed 's/^[ ]*//' | tail -n +2`)
<<<<<<< HEAD
=======
compare() { [[ ${1%:*} -lt ${2%%:*} ]]; }
qsort compare ${arr[*]}
arr=("${qsort_ret[@]}")
#declare -p qsort_ret
DEBUG declare -p arr
>>>>>>> dev
IFS=$OLD_IFS
num=${#arr[*]}

DEBUG echo cropping frames
Y=`convert $infile -format "%h" info:`
for ((i=0;i<num;i++)); do
    color=`echo "${arr[$i]}" | cut -d\  -f5`
    bbox=`echo "${arr[$i]}" | cut -d\  -f2`
    bbox=`echo $bbox  | sed 's/[+x]/:/g'`
    array=(${bbox//:/ })
    #    for j in "${!array[@]}"
    #    do
    #        echo "$i=>${array[j]}"
    #    done;
    X="${array[0]}"
    if [ "$debug" -eq 2 ]; then
        #you have the correct height
        Y="${array[1]}"
    fi
    x="${array[2]}"
    y="${array[3]}"
    
    if [ $extend -ne 0 ]; then
        X=$((X-($extend*2)))
        x=$((x+$extend))
    fi

    if [ "$debug" -lt 2 ] && ( [ "$color" = "gray(0)" ] || [ "$color" = "srgb(0,0,0)" ] ) ; then
        DEBUG echo skipping $i XYxy $X $Y $x $y
        continue;
    fi
    OUTFILE="$outprefix"frame-"$framenumber".tif
    framenumber=$((framenumber+1))
    DEBUG set -x;
    echo cropping $OUTFILE
    convert $infile +repage -crop "$X"x"$Y"+"$x"+"$y" +repage $OUTFILE
    set +x
done

if [ "$debug" -eq 0 ]; then
    rm -f "$tmpoutprefix"*
fi
