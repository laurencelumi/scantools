#!/bin/bash
#
# Licensing:
#
# Copyright Â© Laurence Lumi 2017
# Licensed GNU General Public License v3
# which can be found here https://www.gnu.org/licenses/gpl-3.0.en.html
#

progname=`basename $0`
usage()
	{
	echo >&2 ""
	echo >&2 "$progname:" "$@"
        cat << MESSAGE1
USAGE: $progname gap | holder [-d] [-dd] [-m] [-flip] [-r rotate] [-p pixel] [-z] [-e extend] [-fb fbfuzz] [-f fuzz] [-n number] infile [outfile_prefix]
USAGE: $progname [-h ] [ -help ]

holder    removeholder   the script for trim the film holder
gap       remove gap     the script will remove the film frame gaps

OPTIONS:


-d          debug          provided usefull debuging and leaves intermediate files behind
-dd         debug          more extensive debugging uses full height intermediate files, which may give a different result from no-debug
-m          mirror         mirrors left to right the scan before it is processed, usefull if the negative was scanned emulsion down
-flip       flip           mirrors the scan vertically before it is processed, usefull if the negative was scanned emulsion down
-r          rotate         rotates the scan before it is processed, positive integer <= 360
-p          pixelwidth     the smallest amount of horizontal pixel that could make a usefull image defaults: 250
-e          extend         extend crop on each side in pixels; integer; default=0
-fb         filmbase       fuzz value used as threshold for removing any white areas from the scan
                           if brighest area of the film base is 75% then the threshold should be less than 25%
                           expressed as (integer) percent 0 to 100; default=25
-f          fuzz           fuzz value used for a threshold to find area outside the frame, either the black film holder or the gaps between frames
                           expressed as (integer) percent 0 to 100; default=3 for gap and 10 for holder
-n          frame number   the starting frame number to use in file name; defaults to #1
-z          zip            zip compress the output (the default does not compress the output)

MESSAGE1
exit 1
}
help()
{
    echo >&2 ""
    echo >&2 "$progname:" "$@"
    cat  >&2 << MESSAGE2

NAME: $progname

PURPOSE: to trim the film holder and separate frames of a trimmed film strip

Arguments:

TODO

MESSAGE2
exit 1
}
function DEBUG()
{
 [ ! "$debug" -eq 0 ] &&  $@
}

# quicksorts positional arguments
# return is in array qsort_ret
# Note: iterative, NOT recursive! :)
# First argument is a function name that takes two arguments and compares them
qsort() {
   (($#<=1)) && return 0
   local compare_fun=$1
   shift
   local stack=( 0 $(($#-1)) ) beg end i pivot smaller larger
   qsort_ret=("$@")
   while ((${#stack[@]})); do
      beg=${stack[0]}
      end=${stack[1]}
      stack=( "${stack[@]:2}" )
      smaller=() larger=()
      pivot=${qsort_ret[beg]}
      for ((i=beg+1;i<=end;++i)); do
         if "$compare_fun" "${qsort_ret[i]}" "$pivot"; then
            smaller+=( "${qsort_ret[i]}" )
         else
            larger+=( "${qsort_ret[i]}" )
         fi
      done
      qsort_ret=( "${qsort_ret[@]:0:beg}" "${smaller[@]}" "$pivot" "${larger[@]}" "${qsort_ret[@]:end+1}" )
      if ((${#smaller[@]}>=2)); then stack+=( "$beg" "$((beg+${#smaller[@]}-1))" ); fi
      if ((${#larger[@]}>=2)); then stack+=( "$((end-${#larger[@]}+1))" "$end" ); fi
   done
}
function cleanup {
if [ ! -z "$tmpfileprefix" ] &&  [ "$debug" -eq 0 ]; then
    rm -f "$tmpfileprefix"*
fi
}
trap cleanup EXIT

tmpdir="./"
debug=0
tmpprefix=$tmpdir"_vt_"
filmbase=5 #can reduce this value if increase the radius of the blur
framenumber=1
pixel=250
extend=0
zip="+compress"

if [ "$1" = "holder" ]; then
    mode="holder"
    fuzz=4
    shift
elif [ "$1" = "gap" ]; then
    mode="gap"
    fuzz=3
    shift
else
    echo "must specify either holder or gap"
    help
fi

while [ $# -gt 0 ]
do
    # get parameters
    case "$1" in
        -h|-help)    # help information
            echo ""
            help
            ;;
        -d)	debug=1
            ;;
        -dd)	debug=2
            ;;
        -m)	mirror="-flop"
            ;;
        -flip)	flip="-flip"
            ;;
        -r)    # rotate
            shift
            rotate="$1"
            if [[ ! "$rotate" =~ ^[0-9]+$ ]] || [ "$rotate" -lt 0 -o "$rotate" -gt 360 ]; then
                echo "--- rotate=$rotate must be a positive integer value between 0 and 360 ---"
                usage
            fi
            rotate="-rotate $rotate +repage"
            ;;
        -p)    # pixel
            shift
            pixel="$1"
            if [[ ! "$pixel" =~ ^[0-9]+$ ]]; then
                echo "--- pixel=$pixel must be a positive integer value ---"
                usage
            fi
            ;;
        -e)    # extend
            shift
            extend="$1"
            if [[ ! "$extend" =~ ^[0-9]+$ ]]; then
                echo "--- extend=$extend must be a positive integer value ---"
                usage
            fi
            ;;
        -fb)    # filmbase
            shift
            filmbase="$1"
            if [[ ! "$filmbase" =~ ^[0-9]+$ ]] || [ "$filmbase" -lt 0 -o "$filmbase" -gt 100 ]; then
                echo "--- filmbase=$filmbase must be a positive integer value between 0 and 100 ---"
                usage
            fi
            ;;
        -f)    # fuzz
            shift
            fuzz="$1"
            if [[ ! "$fuzz" =~ ^[0-9]+$ ]] || [ "$fuzz" -lt 0 -o "$fuzz" -gt 100 ]; then
                echo "--- fuzz=$fuzz must be a positive integer value between 0 and 100 ---"
                usage
            fi
            ;;
        -n)    # number
            shift
            framenumber="$1"
            if [[ ! "$framenumber" =~ ^[0-9]+$ ]]; then
                echo "--- framenumber=$framenumber must be a integer value  ---"
                usage
            fi
            ;;
        -z)
            zip="-compress zip"
            ;;
        -)    # STDIN and end of arguments
            break
            ;;
        -*)    # any other - argument
            echo "--- UNKNOWN OPTION ---"
            usage
            ;;
        *)     # end of arguments
            break
            ;;
    esac
    shift   # next option
done

infile=$1
outprefix=$2

if [ -z $infile ]
then
    echo "must provide a filename"
    usage
fi
if [ ! -f "$infile" -o ! -r "$infile" ]; then
    echo "Cannot open: $infile"
    exit 1
fi

if [ -z $outprefix ]; then
    outprefix=${infile%".tif"}_
else
    outprefix=${outprefix%".tif"}_
fi
tmpfileprefix="$tmpprefix"`date +%N``basename "$outprefix"`
DEBUG echo tmpfileprefix: $tmpfileprefix
DEBUG echo outprefix: $outprefix

#first orientate the image if necessary
if [ ! -z "$mirror" ] || [ ! -z "$flip" ] || [ ! -z "$rotate" ]; then
    echo "re orientating scan before processing"
    reorientatedfile="$tmpfileprefix"reoreintated.tif
    convert $infile $mirror $rotate $flip +compress "$reorientatedfile"
    infile="$reorientatedfile"
fi

DEBUG set -x;

if [ $mode = "gap" ]; then
    #remove any sprocket holes or missing bits of film use a default of 5% this mean the film base must be darker than 5%
    tmpfile0="$tmpfileprefix"0work.tif
    convert $infile -fuzz "$filmbase"% -fill black -opaque white +compress "$tmpfile0"
else
    #skip the fill step and just use input file directly
    tmpfile0="$infile"
fi

if [ "$debug" -eq 2 ]; then
    #do the conversion in both X an Y easier to visualise but unecessary as all pixel are identical in a vertical line
    #caution this may have side effects as the logic is different compared to the low debug levels
    XY=`convert $infile -format "%wx%h" info:`
    convert "$tmpfile0" -scale x1! -scale $XY! +compress "$tmpfileprefix"1work.tif
else
    convert "$tmpfile0" -scale x1! +compress "$tmpfileprefix"1work.tif
fi

if [ $mode = "gap" ]; then
    stripcolor=(`convert "$tmpfileprefix"1work.tif -strip -blur 25x65355 -format \
        "%[fx: maxima.r * 100 ] %[fx: maxima.g * 100 ] %[fx: maxima.b * 100 ] " info:`)
    #num=${#stripcolor[*]}
    #echo num:$num
    #for ((i=0;i<num;i++)); do
    #    echo SC:${stripcolor[$i]}
    #done
    opaque="rgb("${stripcolor[0]}"%,"${stripcolor[1]}"%,"${stripcolor[2]}"%)"
    
    #retrace steps
    mv "$tmpfile0" "$tmpfile0"_
    mv "$tmpfileprefix"1work.tif "$tmpfileprefix"1work.tif_
    convert $infile -fuzz "$filmbase"% -fill $opaque -opaque white +compress "$tmpfile0"
    if [ "$debug" -eq 2 ]; then
        #do the conversion in both X an Y easier to visualise but unecessary as all pixel are identical in a vertical line
        #caution this may have side effects as the logic is different compared to the low debug levels
        XY=`convert $infile -format "%wx%h" info:`
        convert "$tmpfile0" -scale x1! -scale $XY! +compress "$tmpfileprefix"1work.tif
    else
        convert "$tmpfile0" -scale x1! +compress "$tmpfileprefix"1work.tif
    fi
else
    opaque="black"
fi


convert "$tmpfileprefix"1work.tif -fuzz "$fuzz"% -fill black -opaque "$opaque" +fuzz -fill white +opaque black +compress "$tmpfileprefix"2work.tif
#morphology could be adjusted to remove ghost frames i.e the gap must be x pixels wide
#convert "$tmpfileprefix"2work.tif -morphology open "5x1:0,1,1,1,0" "$tmpfileprefix"3work.tif
convert "$tmpfileprefix"2work.tif -morphology open "Rectangle:"$pixel"x1" +compress "$tmpfileprefix"3work.tif

arr=()
OLD_IFS=$IFS
IFS=$'\n'
arr=(`convert "$tmpfileprefix"3work.tif -type bilevel \
-define connected-components:verbose=true \
-define connected-components:mean-color=true \
-connected-components 4 \
null: | sed 's/^[ ]*//' | tail -n +2`)
set +x
DEBUG echo array size is: ${#arr[*]}
compare() { [[ ${1%:*} -lt ${2%%:*} ]]; }
qsort compare ${arr[*]}
arr=("${qsort_ret[@]}")
#declare -p qsort_ret
DEBUG declare -p arr
IFS=$OLD_IFS
num=${#arr[*]}

DEBUG echo cropping frames
Y=`convert $infile -format "%h" info:`
for ((i=0;i<num;i++)); do
    color=`echo "${arr[$i]}" | cut -d\  -f5`
    bbox=`echo "${arr[$i]}" | cut -d\  -f2`
    bbox=`echo $bbox  | sed 's/[+x]/:/g'`
    array=(${bbox//:/ })
    #    for j in "${!array[@]}"
    #    do
    #        echo "$i=>${array[j]}"
    #    done;
    X="${array[0]}"
    if [ "$debug" -eq 2 ]; then
        #you have the correct height
        Y="${array[1]}"
    fi
    x="${array[2]}"
    y="${array[3]}"

    if [ $extend -ne 0 ]; then
        X=$((X-($extend*2)))
        x=$((x+$extend))
    fi

    if [ $X -eq 1 ]; then
        DEBUG echo skipping $i because it has X value of 1 XYxy $X $Y $x $y
        #this should not probably happen now that -colors 2 was added to the fill command
        echo THIS IS HAPPENING
        continue;
    fi

    if [ "$debug" -lt 2 ] && ( [ "$color" = "gray(0)" ] || [ "$color" = "srgb(0,0,0)" ] || [ "$color" = "gray(0%)" ] ) ; then
        DEBUG echo skipping $i XYxy $X $Y $x $y
        continue;
    fi
    DEBUG echo using ${arr[$i]}
    outfile="$outprefix"frame-`printf "%03d" "$framenumber"`.tif
    framenumber=$((framenumber+1))
    echo cropping $outfile
    DEBUG set -x;
    convert $infile +repage -crop "$X"x"$Y"+"$x"+"$y" +repage $zip $outfile
    set +x
done

